#용어 

https://legacy.reactjs.org/docs/reconciliation.html

https://velog.io/@syoung125/eact-Reconciliation%EC%9D%B4%EB%9E%80-virtual-DOM-%EB%A6%AC%EC%95%A1%ED%8A%B8%EA%B0%80-%EC%84%A0%EC%96%B8%EC%A0%81

---
- 리액트는 선언적 API를 제공하기 때문에 갱신이 될 때마다 매번 무엇이 바뀌었는지를 걱정할 필요가 없다
- 리액트의 컴포넌트에서 prop이나 state가 변경될 때, 직전에 렌더링된 요소와 새로 반환된 요소를 비교하고 DOM을 업데이트하는 과정을 일컫는다.
- 하나의 트리를 다른 트리로 변환하기 위한 그 어떤 최첨단의 알고리즘도 복잡도는 높기 마련.
- 따라서, 다음 두 가지 가정을 기반하여 비교 알고리즘(The Diffing Algorithm)을 구현했다.

1. 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다
2. `key` prop을 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시할 수 있다

### The Diffing Algorithm
- 루트 엘리먼트가 다른 경우
	- 이전 트리를 버리고 완전히 새로운 트리를 구축한다
- 같은 타입의 Dom element인 경우
	- 같은 속성은 그대로 두고, 다른 속성만 변경을 진행한다

- [자식에 대한 재귀적 처리](https://legacy.reactjs.org/docs/reconciliation.html#recursing-on-children)
	- 마지막에 자식 노드를 추가하는 경우, 추가된 노드만 트리에 추가하면 된다
	- 만약 맨 앞에 추가된다면 모든 자식 노드를 변경해야 한다 -> 부작용 야기
		- 이를 해결하기 위해 `key`  속성이 필요하다
		- 새로운 `key`를 갖는 노드는 추가하고, 나머지 노드는 그대로 옮겨진다

> [!인덱스로 key를 사용하는 것은 최후의 수단!]
> 컴포넌트는 키를 기반으로 업데이트되고 재사용되는데, 만약 key값이 인덱스라면 아이템을 이동하는 것은 곧 key를 변경하게 된다. 결과적으로, 컴포넌트의 상태가 예상치 못한 방향으로 꼬이게 된다.